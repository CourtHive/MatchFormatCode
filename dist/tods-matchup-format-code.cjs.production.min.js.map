{"version":3,"file":"tods-matchup-format-code.cjs.production.min.js","sources":["../src/index.js"],"sourcesContent":["/*\n * TODO: if the final set is NOT different then don't include in string\n */\n\nconst SET = \"SET\";\nconst NOAD = \"NOAD\";\nconst TIMED = \"timed\";\nconst FINAL = \"final\";\nconst NORMAL = \"normal\";\nconst setTypes = {\n  S: NORMAL,\n  F: FINAL\n};\n\nconst matchUpFormatCode = (function() {\n  const fx = {};\n\n  fx.stringify = matchformatobject => {\n    if (matchformatobject && typeof matchformatobject === \"object\") {\n      if (matchformatobject.timed && !isNaN(matchformatobject.minutes))\n        return timedSetFormat(matchformatobject);\n      if (matchformatobject.bestOf && matchformatobject.setFormat)\n        return getSetFormat(matchformatobject);\n    }\n  };\n\n  function timedSetFormat(matchformatobject) {\n    return `T${matchformatobject.minutes}`;\n  }\n\n  function getSetFormat(matchformatobject) {\n    const bestOfValue = getNumber(matchformatobject.bestOf);\n    const bestOfCode = (bestOfValue && `${SET}${bestOfValue}`) || \"\";\n    const setCountValue = stringifySet(matchformatobject.setFormat);\n    const setCode = (setCountValue && `S:${setCountValue}`) || \"\";\n    const finalSetCountValue = stringifySet(matchformatobject.finalSetFormat);\n    const finalSetCode =\n      (bestOfValue > 1 &&\n        finalSetCountValue &&\n        !finalSetCountValue.invalid &&\n        `F:${finalSetCountValue}`) ||\n      \"\";\n    const valid =\n      bestOfCode &&\n      setCountValue &&\n      !setCountValue.invalid &&\n      (!finalSetCountValue || !finalSetCountValue.invalid);\n\n    if (valid) {\n      return [bestOfCode, setCode, finalSetCode].filter(f => f).join(\"-\");\n    }\n  }\n\n  function stringifySet(setObject) {\n    if (setObject) {\n      if (typeof setObject === \"object\") {\n        if (setObject.timed) return timedSetFormat(setObject);\n        if (setObject.tiebreakSet) return tiebreakFormat(setObject.tiebreakSet);\n        const setToValue = getNumber(setObject.setTo);\n        if (setToValue) {\n          const NoAD = (setObject.NoAD && NOAD) || \"\";\n          const setTiebreakValue = tiebreakFormat(setObject.tiebreakFormat);\n          const setTiebreakCode =\n            (setTiebreakValue &&\n              !setTiebreakValue.invalid &&\n              `/${setTiebreakValue}`) ||\n            \"\";\n          const tiebreakAtValue = getNumber(setObject.tiebreakAt);\n          const tiebreakAtCode =\n            (tiebreakAtValue &&\n              tiebreakAtValue !== setToValue &&\n              `@${tiebreakAtValue}`) ||\n            \"\";\n          const valid = !setTiebreakValue || !setTiebreakValue.invalid;\n          if (valid) {\n            return `${setToValue}${NoAD}${setTiebreakCode}${tiebreakAtCode}`;\n          } else {\n            return { invalid: true };\n          }\n        } else {\n          return { invalid: true };\n        }\n      }\n    }\n  }\n\n  function tiebreakFormat(tieobject) {\n    if (tieobject) {\n      if (typeof tieobject === \"object\" && !tieobject.tiebreakTo) {\n        return \"\";\n      } else if (\n        typeof tieobject === \"object\" &&\n        getNumber(tieobject.tiebreakTo)\n      ) {\n        return `TB${tieobject.tiebreakTo}${tieobject.NoAD ? NOAD : \"\"}`;\n      } else {\n        return { invalid: true };\n      }\n    }\n  }\n\n  fx.parse = matchformatcode => {\n    if (matchformatcode && typeof matchformatcode === \"string\") {\n      const type =\n        matchformatcode.indexOf(\"T\") === 0\n          ? \"timed\"\n          : matchformatcode.indexOf(SET) === 0\n          ? SET\n          : \"\";\n      if (type === TIMED) return parseTimedSet(matchformatcode);\n      if (type === SET) return setsMatch(matchformatcode);\n    }\n  };\n\n  function setsMatch(formatstring) {\n    const parts = formatstring.split(\"-\");\n\n    const bestOf = getNumber(parts[0].slice(3));\n    const setFormat = parts && parseSetFormat(parts[1]);\n    const finalSetFormat = parts && parseSetFormat(parts[2]);\n    const validBestOf = bestOf && bestOf < 6;\n    const validFinalSet =\n      !parts[2] || (finalSetFormat && !finalSetFormat.invalid);\n    const validSetsFormat = setFormat && !setFormat.invalid;\n\n    const result = { bestOf, setFormat };\n    if (finalSetFormat) result.finalSetFormat = finalSetFormat;\n    if (validBestOf && validSetsFormat && validFinalSet) return result;\n  }\n\n  function parseSetFormat(formatstring) {\n    if (formatstring && formatstring[1] === \":\") {\n      const parts = formatstring.split(\":\");\n      const setType = setTypes[parts[0]];\n      const setFormatString = parts[1];\n      if (setType && setFormatString) {\n        const tiebreakSet = setFormatString.indexOf(\"TB\") === 0;\n        if (tiebreakSet)\n          return { tiebreakSet: parseTiebreakFormat(setFormatString) };\n        const timedSet = setFormatString.indexOf(\"T\") === 0;\n        if (timedSet) return parseTimedSet(setFormatString);\n        const parts = formatstring.match(/^[FS]{1}:(\\d+)([A-Za-z]*)/);\n        const NoAD = (parts && isNoAD(parts[2])) || false;\n        const validNoAD = !parts || !parts[2] || NoAD;\n        const setTo = parts && getNumber(parts[1]);\n        const tiebreakAtValue = parseTiebreakAt(setFormatString);\n        const validTiebreakAt =\n          !tiebreakAtValue || (tiebreakAtValue && !tiebreakAtValue.invalid);\n        const tiebreakAt = (validTiebreakAt && tiebreakAtValue) || setTo;\n        const tiebreakFormat = parseTiebreakFormat(\n          setFormatString.split(\"/\")[1]\n        );\n        const validTiebreak = !tiebreakFormat || !tiebreakFormat.invalid;\n        const result = { setTo };\n        if (NoAD) result.NoAD = true;\n        if (tiebreakFormat) {\n          result.tiebreakFormat = tiebreakFormat;\n          result.tiebreakAt = tiebreakAt;\n        } else {\n          result.noTiebreak = true;\n        }\n        return (\n          (setTo &&\n            validNoAD &&\n            validTiebreak &&\n            validTiebreakAt &&\n            result) || { invalid: true }\n        );\n      }\n    }\n  }\n\n  function parseTiebreakAt(setFormatString) {\n    const tiebreakAtValue =\n      setFormatString &&\n      setFormatString.indexOf(\"@\") > 0 &&\n      setFormatString.split(\"@\");\n    if (tiebreakAtValue) {\n      const tiebreakAt = getNumber(tiebreakAtValue[1]);\n      return tiebreakAt || { invalid: true };\n    }\n  }\n\n  function parseTiebreakFormat(formatstring) {\n    if (formatstring) {\n      if (formatstring.indexOf(\"TB\") === 0) {\n        const parts = formatstring.match(/^TB(\\d+)([A-Za-z]*)/);\n        const tiebreakToString = parts && parts[1];\n        const NoAD = parts && isNoAD(parts[2]);\n        const validNoAD = !parts || !parts[2] || NoAD;\n        const tiebreakTo = getNumber(tiebreakToString);\n        if (tiebreakTo && validNoAD) {\n          const result = { tiebreakTo };\n          if (NoAD) result.NoAD = true;\n          return result;\n        } else {\n          return { invalid: true };\n        }\n      } else {\n        return { invalid: true };\n      }\n    }\n  }\n\n  function parseTimedSet(formatstring) {\n    const timestring = formatstring.slice(1);\n    const minutes = getNumber(timestring);\n    if (minutes) return { timed: true, minutes };\n  }\n\n  function isNoAD(formatstring) {\n    return formatstring && formatstring.indexOf(NOAD) >= 0;\n  }\n\n  function getNumber(formatstring) {\n    return !isNaN(Number(formatstring)) && Number(formatstring);\n  }\n\n  return fx;\n})();\n\nexports.matchUpFormatCode = matchUpFormatCode;\n"],"names":["setTypes","S","F","exports","matchUpFormatCode","fx","timedSetFormat","matchformatobject","minutes","stringifySet","setObject","timed","tiebreakSet","tiebreakFormat","setToValue","getNumber","setTo","NoAD","setTiebreakValue","setTiebreakCode","invalid","tiebreakAtValue","tiebreakAt","tiebreakAtCode","tieobject","tiebreakTo","parseSetFormat","formatstring","parts","split","setFormatString","indexOf","parseTiebreakFormat","parseTimedSet","match","isNoAD","validNoAD","parseTiebreakAt","validTiebreakAt","validTiebreak","result","noTiebreak","tiebreakToString","slice","isNaN","Number","stringify","bestOf","setFormat","bestOfValue","bestOfCode","setCountValue","setCode","finalSetCountValue","finalSetFormat","filter","f","join","getSetFormat","parse","matchformatcode","type","validBestOf","validFinalSet","validSetsFormat","setsMatch"],"mappings":"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"}